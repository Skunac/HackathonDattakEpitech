<?php

namespace App\Controller;

use App\Entity\User;
use App\Entity\Technology;
use App\Entity\CVE;
use App\Entity\UserCVE;
use App\Service\CveFetcherService;
use DateTime;
use DateTimeImmutable;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Bundle\SecurityBundle\Security;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/dashboard')]
class DashboardController extends AbstractController
{
    public function __construct(
        private EntityManagerInterface $entityManager,
        private Security $security,
        private CveFetcherService $fetcherService,
    ) {
    }

    #[Route('', name: 'app_dashboard', methods: ['GET'])]
    public function index(Request $request): Response
    {
        /** @var User $user */
        $user = $this->security->getUser();

        if (!$user) {
            throw $this->createNotFoundException('Utilisateur non trouvÃ©');
        }

        $technologies = $user->getTechnologies();

        $startDate = new DateTime('-30 days');
        $endDate = new DateTime('now');

        $technologyNames = [];
        foreach ($technologies as $techno) {
            $technologyNames[] = $techno->getName();
        }

        $cvesByTechnology = [];
        if (!empty($technologyNames)) {
            $cvesByTechnology = $this->fetcherService->fetchMultipleTechnologies(
                $technologyNames,
                $startDate,
                $endDate
            );

            // Save CVEs to database
            foreach ($cvesByTechnology as $technologyName => &$cves) {
                $technology = $this->entityManager->getRepository(Technology::class)->findOneBy([
                    'name' => $technologyName
                ]);

                if (!$technology) {
                    continue;
                }

                foreach ($cves as &$cveData) {
                    if (!isset($cveData['cveId']) || empty($cveData['cveId'])) {
                        continue;
                    }

                    $existingCVE = $this->entityManager->getRepository(CVE::class)->findOneBy([
                        'cveId' => $cveData['cveId']
                    ]);

                    if (!$existingCVE) {
                        $cve = new CVE();
                        $cve->setCveId($cveData['cveId']);
                        $cve->setDescription($cveData['description'] ?? 'No description available');
                        $cve->setCvssScore($cveData['cvssScore']);
                        $cve->setSeverity($cveData['severity'] ?? 'UNKNOWN');
                        $cve->setPublishedDate($cveData['publishedDate'] ?? new DateTime());
                        $cve->setUrl($cveData['url'] ?? '');
                        $cve->setTechnologies($technology);

                        $this->entityManager->persist($cve);

                        try {
                            $this->entityManager->flush();
                            $cveData['id'] = $cve->getId();
                        } catch (\Exception $e) {
                            $this->entityManager->rollback();
                            error_log("Error saving CVE {$cveData['cveId']}: " . $e->getMessage());
                            continue;
                        }
                    } else {
                        $cveData['id'] = $existingCVE->getId();
                    }
                }
            }
            unset($cves);
        }

        $userCVEMap = [];
        $userCVEs = $this->entityManager->getRepository(UserCVE::class)->findBy([
            'UserRelation' => $user
        ]);

        foreach ($userCVEs as $userCVE) {
            $cveIdString = $userCVE->getCVE()->getCveId();
            $userCVEMap[$cveIdString] = [
                'checked' => $userCVE->isChecked(),
                'id' => $userCVE->getCVE()->getId()
            ];
        }

        return $this->render('dashboard/index.html.twig', [
            'user' => $user,
            'technologies' => $technologies,
            'cvesByTechnology' => $cvesByTechnology,
            'userCVEMap' => $userCVEMap,
            'startDate' => $startDate,
            'endDate' => $endDate,
        ]);
    }

    #[Route('/cve/toggle-check', name: 'app_dashboard_toggle_cve_check', methods: ['POST'])]
    public function toggleCveCheck(Request $request): JsonResponse
    {
        /** @var User $user */
        $user = $this->security->getUser();

        if (!$user) {
            return new JsonResponse(['error' => 'User not found'], 404);
        }

        $data = json_decode($request->getContent(), true);
        $cveIdString = $data['cveId'] ?? null;
        $dbId = $data['dbId'] ?? null;

        if (!$cveIdString) {
            return new JsonResponse(['error' => 'CVE ID is required'], 400);
        }

        $cve = null;
        if ($dbId) {
            $cve = $this->entityManager->getRepository(CVE::class)->find($dbId);
        }

        if (!$cve) {
            $cve = $this->entityManager->getRepository(CVE::class)->findOneBy(['cveId' => $cveIdString]);
        }

        if (!$cve) {
            return new JsonResponse(['error' => 'CVE not found in database. Please refresh the page.'], 404);
        }

        $userCVE = $this->entityManager->getRepository(UserCVE::class)->findOneBy([
            'UserRelation' => $user,
            'CVE' => $cve
        ]);

        if (!$userCVE) {
            $userCVE = new UserCVE();
            $userCVE->setUserRelation($user);
            $userCVE->setCVE($cve);
            $userCVE->setStatus('new');
            $userCVE->setCreatedAt(new DateTimeImmutable());
            $userCVE->setUpdatedAt(new DateTimeImmutable());
            $userCVE->setChecked(true);
            $this->entityManager->persist($userCVE);
        } else {
            $userCVE->setChecked(!$userCVE->isChecked());
            $userCVE->setUpdatedAt(new DateTimeImmutable());
        }

        $this->entityManager->flush();

        return new JsonResponse([
            'success' => true,
            'checked' => $userCVE->isChecked(),
            'dbId' => $cve->getId()
        ]);
    }
}
